---
title: Go圣经提炼
date: 2021-09-02 10:05:16
categories:
- Go圣经
tags:
---

## 前言

本文将分为 12 节 对 `Go圣经` 进行知识点提炼


## 程序结构

### 命名

包一级范围内可以声明常量(`const`)也可以声明变量(`var`)，区别在于：
1. 常量声明时必须要同时初始化（赋值），变量可以只声明，后续再初始化（赋值）
2. 常量不可重新赋值，也就是无法更新，变量可以更新

包一级声明的常量或者变量在整个包范围内（不限文件）都是可以使用的。而函数内部的声明则只能在函数局部范围内被使用，这里的函数的局部范围是当前函数，如果是当前函数内嵌了其他函数，在其他函数内是不能直接使用的，必须要通过参数引入，而实际上通过参数引入的参数已经不是最开始声明的量，而是值的拷贝，也就是在内嵌函数中修改当前参数，是不会反映在声明的量上的。



### 声明

标准变量声明
```
var 变量名字 类型 = 表达

// or
var 变量名字 类型
变量名字 = 表达
```
简短变量声明
```
变量名字 := 表达
```
> 注意：多次使用简短变量声明声明同名的变量，后面出现的变量实际上仅执行赋值操作，而且多次间断变量声明必须要后续声明中至少存在一个不同名的变量声明，如果都是同名的，则需要更改为赋值操作

指针声明
```
x := 1
p := &x 
```
这里 `p` 代表的一个指针，类型是 `*int`，值则是 `x` 的地址

`new` 函数



### 


## 基础数据类型

## 复合数据类型
### 数组
数组是一组同类型的合集。这里类型不限于基础类型，也可以是复合类型

数组声明即带零值，同时默认自带索引下标（可以不连续）

数组的可比较性是有数组元素的可比较性决定的，如果不同数组内的元素都是可以比较的，那么不同数组本身也是可以比较的。

由于数组长度是固定的，因此数组仅能够支持元素值的读取与更新，其他操作均支持

### Slice (切片)

Slice 代表变长序列，和数组是不同的数据类型。由指针、长度和容量构成，其中容量是可变的，这里注意长度和容量不一定相同，但是成都肯定是小于容量的，字面上就可以感受到长度和容量的区别，长度指对象实际拥有元素的数量，而容量是指对象能够容纳的元素数量。

![slice](https://books.studygolang.com/gopl-zh/images/ch4-01.png)

从图中可以看出 `Slice` 的存储表现，同时也可以看到它是一个引用值，由一个数组而生成不同的 `Slice` 的可能会有重合的部分，也就是当更新其中一个 `Slice` 的值的时候，其他存在重合部分的 `Slice` 也是会更新的。这点和数组表现是不同的，由于数组不能够改变长度，单纯的赋值给另外一个变量，实际上是对象的复制，也就是其中一个数组更新，另一个数组是不受影响的。

由于 `Slice` 的元素是间接引用的，所以 `Slice` 不支持直接比较，但可以展开来对比。`Slice` 唯一支持和 `nil` 做对比较，这里注意为 `nil` 的 `Slice` 是没有底层数组的，其容量和长度都是0，但是存在非 `nil` 值的 `Slice`的容量和长度都是 0 的情况，这种 `Slice` 是有底层数组的，也是可以被寻址。

前面我们看到 `[m:n]` 的方式来生成 `Slice`，也可以通过 `make([]T, len)` 的方式来生成 `Slice`

> 注意 append 函数不能保证不同 slice 的底层是否一致，但是 copy 函数的不同 slice 底层是不一致的，也就是改变其中一个 slice 的元素，对另一个 slice 没有影响。

slice 的容量是自动扩增的，遵循 2 倍当前容量的方式扩增，当使用 append 函数对 slice 进行值添加，会触发容量扩增，当需要扩增时，append 函数内部采用 copy 方法重新生成一个 slice，前面提到引用将产生变化，扩增的表现则是新的 slice 将和之前的 slice 不再共享底层数据。所以对扩增之后的 slice 进行值更新，将不再同步。

### Map

```
var m1 map[string]int
m1 = map[string]int{
    "key": 1,
}

# 这里注意不能使用 m1["key"] = 1 因为声明的 map 默认是 nil

// or

m2 := make(map[string]int)
m2["key"] = 1

// or

m3 := map[string]int{
    "key": 1,
}
```

map 不支持元素取址操作，map 中的元素是无序的，这个有别于数组和 slice 这种有默认元素下标（0， 1， ...）的类型

map 支持下面的取值操作，通过判断 ok 来确定值是否存在，而不单单判断其零值 
```
if age, ok := ages["bob"]; !ok {
    // ...
}

```

### 结构体

定义
```
type Employee struct {
    ID int
    Name string
    Address string
    DoB time.Time
    Position string
    Salary int
    ManagerID int
}
var dilbert Employee
```
使用
```
dilbert.Salary -= 5000

var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (proactive team player)
```

结构体成员的顺序对结构是有影响的，也就是说相同的成员顺序不一样，也是不同的结构体。结构体成员不能有自身类型，却可以有自身类型的指针类型

结构体初始化要么同时指定成员名，要么就不指定，不能部分指定。不能在外部包中初始化结构体中的未导出的成员，注意是`未导出`的。

结构体嵌套，其中匿名成员，在字面量初始化时，不能跳过成员名，而引用赋值却可以。

### JOSN

```
type Movie struct {
    Title string
    Year int `json:"released"`
    Color bool `json:"color,omitempty"`
    Actors []string
}
```
体会上面结构在 json Marshal 中的处理情况

## 函数

* 多值返回
* 错误处理  
`Go` 中错误基本上都是以返回值的形式表现，不会引起程序的中断。
* 函数值（闭包理解）
* 可变参数（ ... ，如果参数以 slice 传入，必须在调用时追加 ...）
* Deferred 函数，延迟到函数执行完毕时才执行
* Panic 异常，panic 发生则执行 defer，也可以使用 recover 从 panic 中恢复，也就通常将 recover 放在 defer 中

## 方法

这里要区分方法和函数的定义的区别，主要是方法是对象的函数（属性），脱离了对象的方法就是函数，这里体现的是 `OOP` 的归属关系

理解 `Go` 方法实现的形式，尤其其中通过嵌入结构体来进行扩展类型的形式可以实现

### 封装

减少暴露，隐藏细节，避免任意修改


## 接口

接口类型
```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```
接口类型也支持嵌套，`Go` 中实现接口的条件，就是某个类型实现了接口类型定义的所有方法

接口值，是有类型和类型具体的值组成，那么这里的类型就是接口类型，值则是具体的接口（一个接口）。可以理解为类型是一种定义，而值则是实现了这种定义的具体表现。

```
var w io.Writer
w = os.Stdout
```

![接口值](https://books.studygolang.com/gopl-zh/images/ch7-02.png)

上面就是一个典型的接口值的描述，`w` 声明完成之后，就是图中左部分，声明完成是 `value` 是 nil，执行接口类型值赋值之后 `w` 便是一个接口值。

总结就是接口也是有值的。我们讲一个某个类型实现了某个接口，实际上是指这个类型实现这个接口类型定义的所有方法，我们称这个类型实现了这个接口，这里表现的接口是类型概念。

### 类型断言

```
if f, ok := w.(*os.File); ok {
    // ...
}
```

## Goroutines 和 Channels

`并发` 与 `并行`

> 并发：支持多个动作同时执行
> 并行：同时执行多个动作

### Channels

* 不带缓存的 Channels (同步消息)
* 串联的 Channels (Pipleline)，也就是在 goroutine 中读取前一个 groutine 中写入的 channel 中的值
* 带缓存的 Channels ，也就是 channel 长度大于 1

## 基于共享变量的并发

## 包和工具

## 测试

## 反射

## 底层编程