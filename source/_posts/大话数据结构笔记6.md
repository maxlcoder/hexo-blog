---
title: 大话数据结构笔记6
date: 2019-10-17 21:52:39
categories:
tags:
---


## 树

### 定义
树（Tree）是n（n≥0）个结点的有限集。n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

对于树的定义还需要强调两点： 1.n>0时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。 2.m>0时，子树的个数没有限制，但它们一定是互不相交的。

### 结点分类

树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（De-gree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。

### 结点关系

结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。嗯，为什么不是父或母，叫双亲呢？呵呵，对于结点来说其父母同体，唯一的一个，所以只能把它称为双亲了。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D、B、A都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。

## 二叉树

二叉树具有五种基本形态： 1.空二叉树。 2.只有一个根结点。 3.根结点只有左子树。 4.根结点只有右子树。 5.根结点既有左子树又有右子树。

### 特殊二叉树

1．斜树

所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。

2．满二叉树

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

3．完全二叉树

对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 

### 二叉树性质

性质1：在二叉树的第i层上至多有 $2^{i-1}$ 个结点（i≥1）。

性质2：深度为k的二叉树至多有$2^k-1$个节点（k≥1）

性质3：对任何一棵二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。

性质4：具有n个结点的完全二叉树的深度为$|log_2n+1|$（|x|表示不大于x的最大整数）。

性质5：如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：


1．如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点。

2．如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。 

3．如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。


## 二叉树存储结构

1. 顺序存储
    空间浪费比较大，自顶向下对各节点进行排序存储
2. 链式存储

```c
/* 二叉树的二叉链表结点结构定义 */

/* 结点结构 */

typedef struct BiTNode                  

{

    /* 结点数据 */

    TElemType data;                     

    /* 左右孩子指针 */

    struct BiTNode *lchild, *rchild;    

} BiTNode, *BiTree;

```

## 遍历二叉树

1. 前序遍历
规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

```c
/* 二叉树的前序遍历递归算法 */

void PreOrderTraverse(BiTree T)

{

    if (T == NULL)

        return;

    /* 显示结点数据，可以更改为其他对结点操作 */

    printf("%c", T->data);          

    /* 再先序遍历左子树 */

    PreOrderTraverse(T->lchild);    

    /* 最后先序遍历右子树 */

    PreOrderTraverse(T->rchild);    

}

```


2. 中序遍历
规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。
```c
/* 二叉树的中序遍历递归算法 */

void InOrderTraverse(BiTree T)

{

    if (T == NULL)

        return;

    /* 中序遍历左子树 */

    InOrderTraverse(T->lchild);    

    /* 显示结点数据，可以更改为其他对结点操作 */

    printf("%c", T->data);         

    /* 最后中序遍历右子树 */

    InOrderTraverse(T->rchild);    

}

```


3. 后序遍历
规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。

```
/* 二叉树的后序遍历递归算法 */

void PostOrderTraverse(BiTree T)

{

    if (T == NULL)

        return;

    /* 先后序遍历左子树 */

    PostOrderTraverse(T->lchild);    

    /* 再后序遍历右子树 */

    PostOrderTraverse(T->rchild);    

    /* 显示结点数据，可以更改为其他对结点操作 */

    printf("%c", T->data);           

}

```


### 索引二叉树

```c
/* 二叉树的二叉线索存储结构定义 */

/* Link==0表示指向左右孩子指针 */

/* Thread==1表示指向前驱或后继的线索 */

typedef enum {Link, Thread} PointerTag;    

/* 二叉线索存储结点结构 */

typedef struct BiThrNode                   

{

    /* 结点数据 */

    TElemType data;                        

    /* 左右孩子指针 */

    struct BiThrNode *lchild, *rchild;     

    PointerTag LTag;

    /* 左右标志 */

    PointerTag RTag;                       

} BiThrNode, *BiThrTree;
```

中序索引

```c
BiThrTree pre;                     

/* 全局变量，始终指向刚刚访问过的结点 */

/* 中序遍历进行中序线索化 */

void InThreading(BiThrTree p)

{

    if (p)

    {

        /* 递归左子树线索化 */

        InThreading(p->lchild);    

        /* 没有左孩子 */

        if (!p->lchild)            

        {

            /* 前驱线索 */

            p->LTag = Thread;      

            /* 左孩子指针指向前驱 */

            p->lchild = pre;       

        }

        /* 前驱没有右孩子 */

        if (!pre->rchild)          

        {

            /* 后继线索 */

            pre->RTag = Thread;    

            /* 前驱右孩子指针指向后继（当前结点p） */

            pre->rchild = p;       

        }

        /* 保持pre指向p的前驱 */

        pre = p;                   

        /* 递归右子树线索化 */

        InThreading(p->rchild);    

    }

}
```

### 线索二叉树链表

lchild ltag data rtag rchild


## 树，森林与二叉树转换

* 树转换为二叉树
1.加线。在所有兄弟结点之间加一条连线。 
2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。 
3.层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。

* 森林转换为二叉树
1.把每个树转换为二叉树。 
2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

* 二叉树转换为树
1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。 
2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 
3.层次调整。使之结构层次分明。

* 二叉树转换为森林
1.从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。 
2.再将每棵分离后的二叉树转换为树即可。

## 霍夫曼树

假设有n个权值{w1,w2,...,wn}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称做赫夫曼树。